#include <sstream>
#include <algorithm>
#include<vector>
#include<iostream>
#include "tpolynomproblems.h"
//#include "Base/tinterval.h"
#include "algebra_operations.h"

using namespace std;

TNumeric X_1 = MakeSubscript(TNumeric("x"), TNumeric("1"));
TNumeric X_2 = MakeSubscript(TNumeric("x"), TNumeric("2"));
TNumeric EmptySet = MakeInline(TNumeric("{"), TNumeric("\\empty"), TNumeric("}"));
TNumeric NumericAllReal = MakeInterval(TNumeric("-\\infty"), TNumeric("+\\infty"), false, false);
TInterval IntervalAllRealNumbers(TNumeric("-\\infty"), TNumeric("+\\infty"), false, false);
TNumeric NumPhi = TNumeric("\\phi");

const char TSetOfLinearInequalitiesStr[] = "TSetOfLinearInequalities";
const char TSystemOfLinearInequalitiesStr[] = "TSystemOfLinearInequalities";
const char TSetOfSquareInequalitiesStr[] = "TSetOfSquareInequalitiesStr";
const char TSystemOfSquareInequalitiesStr[] = "TSystemOfSquareInequalitiesStr";



TPolynomConditions::TPolynomConditions(size_t MaxPower, bool HaveRightPart, int Operator) : TProblem()
{
    UnknownVar = TNumeric("x");
    this->HaveRightPart = HaveRightPart;
    SetMaxPower(MaxPower, Operator);
}

TPolynomConditions::TPolynomConditions(const TPolynom& P, bool HaveRightPart, int Operator, bool AllCoef)
{
    UnknownVar = TNumeric("x");
    Conditions = new TNumeric;
    this->HaveRightPart = HaveRightPart;
    RightPartID = P.Coef.size() + 2;
    if(HaveRightPart)
    {
        Conditions->Operator = Operator;
        Conditions->Operands.push_back(TNumeric("0"));
        TNumeric RightPart("0");
        RightPart.ID = RightPartID;
        RightPart.SetEditable(false);
        Conditions->Operands.push_back(TNumeric("0"));
    };

    SetLeftPartP(P, AllCoef);
}

TNumeric TPolynomConditions::GetVarPower(size_t power)
{
    if(power == 0) return TNumeric("1");
    else
    {
        if(power == 1) return (UnknownVar);
        else return (UnknownVar^TNumeric(power));
    };
}


void TPolynomConditions::SetMaxPower(size_t MaxPower, int Operator)
{
    this->MaxPower = MaxPower;
    TNumeric Res;
    for(size_t i = 0; i <= MaxPower; i++)
    {
        TNumeric a(0);
        a.ClearID();
        a.ID = i;
        a.SetEditable(true);
        TNumeric Temp = GetVarPower(i);
        if(i==0)
        {
            if(Temp.Operator == OperatorConst && Temp.K=="1")
                //случай специально для многочленов по x - вместо 0+a*x^0 делаем просто a
                Res = a;
            else
                Res = a*Temp;
        } else {
            Res = a*Temp + Res;
        }
    }
    if(HaveRightPart)
    {
        RightPartID = MaxPower+1;
        TNumeric RightPart("0");
        RightPart.ID = RightPartID;
        RightPart.SetEditable(false);
        if(Conditions != NULL) delete Conditions;
        Conditions = new TNumeric;
        Conditions->Operator = Operator;
        Conditions->Operands.push_back(Res);
        Conditions->Operands.push_back(RightPart);
    } else {
        if(Conditions != NULL) delete Conditions;
        Conditions = new TNumeric(Res);
    }
}


TPolynomConditions::~TPolynomConditions()
{
//nothing to do
}

void TPolynomConditions::SetUnknownVar(TNumeric UnknownVar)
{
    this->UnknownVar = UnknownVar;
    if(Conditions)
    {
        TPolynom P = GetP();
        SetLeftPartP(P, true);
    }
}


vector<TNumeric> TPolynomConditions::GetCoef() const
{
    vector<TNumeric> Coef2;
    if(Conditions == 0) throw "TPolynomConditions::GetCoef: Conditions = 0";
    Coef2.assign(MaxPower+1, TNumeric("0"));
    for(size_t i = 0; i <= MaxPower; i++)
    {
        Coef2[i] = *(Conditions->GetByID(i));
    }
    return Coef2;
}

TPolynom TPolynomConditions::GetP() const
{
    return TPolynom(GetCoef());
}

void TPolynomConditions::SetLeftPartP(const TPolynom &P, bool AllCoef)
{
    if(AllCoef)
        if(P.Coef.size() == 0) MaxPower = 0;
        else MaxPower = P.Coef.size() - 1;
    else MaxPower = P.MajorPower();

    TNumeric Sum;
    for(size_t i = 0; i <= MaxPower; i++)
    {
        TNumeric a = P.GetCoef(i);
        a.ClearID();
        a.ID = i;
        a.SetEditable(true);
        TNumeric Temp = GetVarPower(i);
        if(i==0)
        {
            if(Temp.Operator == OperatorConst && Temp.K=="1")
                //случай специально для многочленов по x - вместо 0+a*x^0 делаем просто a
                Sum = a;
            else
                Sum = a*Temp;
        } else {
            Sum = a*Temp + Sum;
        }
    }
    if(HaveRightPart)
    {
        //Обновляем Conditions, оставляя RightPart и Operator не тронутым (если Conditions != NULL)

        TNumeric RightPart = TNumeric("0");
        int Operator = OperatorEqual;
        if(Conditions == NULL)
        {
            Conditions = new TNumeric;
        }
        else
        {
            RightPart = Conditions->Operands[1];
            Operator = Conditions->Operator;
        };
        RightPartID = MaxPower + 1;
        RightPart.ID = RightPartID;
        Conditions->Operator = Operator;
        Conditions->Operands.clear();
        vector<TNumeric> Test;
            Test.push_back(Sum);
        Conditions->Operands.push_back(Sum);
        Conditions->Operands.push_back(RightPart);
    } else {
        if(Conditions) delete Conditions;
        Conditions = new TNumeric(Sum);
    }
}

void TPolynomConditions::SetLeftPart(const TNumeric &a, const TNumeric &b)
{
vector<TNumeric> v;
    v.push_back(b); //x^0
    v.push_back(a); //x^1
    SetLeftPartP(TPolynom(v));
}

void TPolynomConditions::SetLeftPart(const TNumeric &a, const TNumeric &b, const TNumeric& c)
{
vector<TNumeric> v;
    v.push_back(c); //x^0
    v.push_back(b); //x^1
    v.push_back(a); //x^2
    SetLeftPartP(TPolynom(v));
}


TNumeric* TPolynomConditions::GetCoefP(size_t power)
{
    if(power<=MaxPower)
    {
        return Conditions->GetByID(power);
    } else throw "TPolynomConditions::GetCoef(size_t power): power > MaxPower";
}

TNumeric TPolynomConditions::GetCoef(size_t power) const
{
    if(power<=MaxPower)
    {
        return *(Conditions->GetByID(power));
    } else throw "TPolynomConditions::GetCoef(size_t power): power > MaxPower";
}
TNumeric* TPolynomConditions::GetRightPartP()
{
    return Conditions->GetByID(RightPartID);
}

TNumeric TPolynomConditions::GetRightPart() const
{
    return *(Conditions->GetByID(RightPartID));
}
void TPolynomConditions::SaveToFile(ofstream &f)
{
__int16 MaxPower = this->MaxPower;
    f.write((char*)&MaxPower, sizeof(MaxPower));
__int16 RightPartID = this->RightPartID;
    f.write((char*)&RightPartID, sizeof(RightPartID));
    UnknownVar.WriteToFile(f);
__int16 HaveRightPart;
    if(this->HaveRightPart) HaveRightPart = 1;
    else HaveRightPart = 0;
    f.write((char*)&HaveRightPart, sizeof(HaveRightPart));
    TProblem::SaveToFile(f);
}

void TPolynomConditions::LoadFromFile(ifstream &f)
{
__int16 MaxPower, RightPartID;
    f.read((char*)&MaxPower, sizeof(MaxPower));
    this->MaxPower = MaxPower;
    if(MaxPower > 100)
        throw "Incorrect file format";
    f.read((char*)&RightPartID, sizeof(RightPartID));
    this->RightPartID = RightPartID;
    UnknownVar.LoadFromFile(f);
__int16 HaveRightPart;
    f.read((char*)&HaveRightPart, sizeof(HaveRightPart));
    if(HaveRightPart)this->HaveRightPart = true;
    else this->HaveRightPart = false;
    TProblem::LoadFromFile(f);
}

//******************************************************************************************
//******************************************************************************************
TPolynomialEquality::TPolynomialEquality(size_t MaxPower) : TPolynomConditions(MaxPower), TEquality()
{
    if(MaxPower >= 3)
    {
        GetCoefP(0)->K = "1";
        GetCoefP(3)->K = "1";
    };
    if(MaxPower >= 6)
    {
        vector<TNumeric> R;
        R.push_back(TNumeric(-18)/TNumeric(25)); //x^0
        R.push_back(TNumeric(111)/TNumeric(25)); //x^1
        R.push_back(TNumeric(-253)/TNumeric(50)); //x^2
        R.push_back(TNumeric(-143)/TNumeric(20)); //x^3
        R.push_back(TNumeric(309)/TNumeric(100)); //x^4
        R.push_back(TNumeric(22)/TNumeric(5)); //x^5
        R.push_back(TNumeric(1)); //x^6
        R.push_back(TNumeric(0)); //x^7
        R.push_back(TNumeric(0)); //x^8
        R.clear();
        R.assign(9, TNumeric(1));
        this->SetLeftPartP(R);
    }
}

TPolynomialEquality::TPolynomialEquality(const TPolynom& P, bool AllCoef) : TPolynomConditions(P, OperatorEqual, AllCoef), TEquality()
{

}


TPolynomialEquality::~TPolynomialEquality()
{

}

string TPolynomialEquality::GetTask()
{
    stringstream out;
    out<<string((*Phrases)[PhFindRationalRoots])<<MaxPower;
    return out.str();

}

string TPolynomialEquality::GetShortTask()
{
    stringstream out;
    return Phrases->sprintf(PhstPower, MaxPower);
}


bool TPolynomialEquality::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
vector<TNumeric> Coef1; //коэффициенты в виде объектов TNumeric
vector<int> IntCoef;  //целочисленные коэффициенты
    Coef1 = GetCoef();

    Result.Intervals.clear();
    Roots.clear();
    RootsMultiplicity.clear();


    TPolynom P(Coef1);

    size_t MajorPower = P.MajorPower(); //старшая степень с отличным от нуля коэффициентом

    if(MajorPower <= 1)
        // a * x^0 = 0
    {
        TLinearEquality E;
        E.UnknownVar = UnknownVar;
        E.SetLeftPartP(P);
        AddLine(Lines, Ntabs, new TLine(new TText((*Phrases)[PhSolving]), new TNumeric(*E.Conditions)));
        E.GetSolution(Lines, Ntabs);
        //копируем ответ
        Result = E.Result;
        Degenerate = E.Degenerate;
        Roots = E.Roots;
        RootsMultiplicity = E.RootsMultiplicity;
    } else
    if(MajorPower == 2)
    {
        TSquareEquality E;
        E.UnknownVar = UnknownVar;
        E.SetLeftPartP(P);
        AddLine(Lines, Ntabs, new TLine(new TText((*Phrases)[PhSolving]), new TNumeric(*E.Conditions)));
        bool res = E.GetSolution(Lines, Ntabs);
        //копируем ответ
        Result = E.Result;
        Degenerate = E.Degenerate;
        Roots = E.Roots;
        RootsMultiplicity = E.RootsMultiplicity;
        return res;
    } else {

//проверяем, чтобы все коэффициенты были рациональными
//заодно вычисляем НОК знаменателей всех коэффициентов
        int NOK = 1;
        for(size_t Power = 0; Power <= MaxPower; Power++)
            {
            if(P.GetCoef(Power).Operator != OperatorConst)
            {
                P.GetCoef(Power) = P.GetCoef(Power).Simplify(); //пробуем сделать вычисления
            };

            if(P.GetCoef(Power).Operator == OperatorFrac)
            {
                TNumeric Denom = P.GetCoef(Power).Operands[1];
                Denom = Denom.Simplify();
                P.GetCoef(Power).Operands[1] = Denom;

                int intD;
                if(!Denom.IsInteger(&intD))
                {
                    AddLine(Lines, Ntabs, new TText((*Phrases)[PhErrorDenominatorsShouldBeInteger]));
                    return false;
                };
                NOK = GetNOK(NOK, intD);

                TNumeric Nom = P.GetCoef(Power).Operands[0];
                Nom = Nom.Simplify();
                P.GetCoef(Power).Operands[0] = Nom;
                if(!Nom.IsInteger(0))
                {
                    AddLine(Lines, Ntabs, new TText ((*Phrases)[PhErrorNominatorsShouldBeInteger]));
                    return false;
                };
            } else
            if(!P.GetCoef(Power).IsInteger(0))
            {
                AddLine(Lines, Ntabs, new TText ((*Phrases)[PhErrorCoefsShouldBeRational]));
                return false;
            };
        }

        //умножаем все коэф на общий знаменатель
        if(NOK > 1)
        {
            AddLine(Lines, Ntabs, new TLine(new TText ((*Phrases)[PhToCommonDenominator]), new TNumeric(NOK)));
        };
        P = P * TNumeric(TNumeric(NOK));        
        size_t MajorPower = P.MajorPower();
        IntCoef.assign(MajorPower+1, 0);
        for(size_t Power = 0; Power <= MajorPower; Power++)
        {
            if(!P.GetCoef(Power).IsInteger(&IntCoef[Power]))
            {
                AddLine(Lines, Ntabs, new TText ((*Phrases)[PhErrorCanntReduceToRationalForm]));
                return false;
            };
        }

        //Теперь выносим общий множитель всех коэффициентов
        int NOD = GetNOD(IntCoef);
        P = P / TNumeric(NOD);
        for(size_t Power = 0; Power <= MajorPower; Power++)
        {
            if(!P.GetCoef(Power).IsInteger(&IntCoef[Power]))
            {
                AddLine(Lines, Ntabs, new TText ((*Phrases)[PhErrorCanntReduceToRationalForm]));
                return false;
            };
        }

        AddLine(Lines, Ntabs, new TText ((*Phrases)[PhAfterSimplifyingCoefs]));
        AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(P.GetNumeric(UnknownVar), TNumeric(0))));

        //Рассматриваем случай x^k*P(x) = 0
        size_t ZeroXMult = 0; //кратность корня, равна k
        while(ZeroXMult <= MajorPower && P.GetCoef(ZeroXMult) == 0) ZeroXMult++;

        if(ZeroXMult > 0)
        {
            AddLine(Lines, Ntabs, new TLine(new TText((*Phrases)[PhFactorOut]), new TNumeric(MakePow(UnknownVar, TNumeric(ZeroXMult)))));
            AddLine(Lines, Ntabs, new TLine(new TNumeric(MakeEquality(UnknownVar, TNumeric("0"))), new TLine(new TText ((*Phrases)[PhRootWithMultiplicity]), new TNumeric(ZeroXMult))));
            P.Coef.erase(P.Coef.begin(), P.Coef.begin()+ZeroXMult);
            TPolynomialEquality NewP(P, false);
            NewP.SetUnknownVar(UnknownVar);
            AddLine(Lines, Ntabs, new TNumeric(MakeEquality(MakeProd(MakePow(UnknownVar, TNumeric(ZeroXMult)), NewP.Conditions->Operands[0]), TNumeric(0))));
            Degenerate = false;
            Roots.push_back(TNumeric("0"));
            RootsMultiplicity.push_back(ZeroXMult);
            Result.Intervals.push_back(TInterval(TNumeric("0")));
            if(NewP.GetSolution(Lines, Ntabs+1))
            {
                if(NewP.Degenerate)
                {
                    Degenerate = true;
                } else {
                    Roots.insert(Roots.end(), NewP.Roots.begin(), NewP.Roots.end());
                    RootsMultiplicity.insert(RootsMultiplicity.end(), NewP.RootsMultiplicity.begin(), NewP.RootsMultiplicity.end());
                };
                Result = NewP.Result + Result;

            } else {
                return false;
            }
        } else {
            vector<TNumeric> RationalRoots; //найденные корни без учёта кратности
            Degenerate = false;
            int FreeMember = IntCoef[0];
            int MajorMember = IntCoef[MajorPower];
            vector<int> FreeMemberMults = IntFactorize(FreeMember);
            vector<int> MajorMemberMults = IntFactorize(MajorMember);
            if(Lines)
                {
                AddLine(Lines, Ntabs, new TText ((*Phrases)[PhFactorizeFreeTerm]));
                TNumeric Temp;
                Temp.Operator = OperatorProd;
                    if(FreeMemberMults.size()==1)
                    AddLine(Lines, Ntabs+1, new TLine(new TNumeric(abs(FreeMember)), new TText ((*Phrases)[PhIsSimpleNumber])));
                else
                {
                    for(size_t i = 0; i < FreeMemberMults.size(); i++) Temp.Operands.push_back(TNumeric(FreeMemberMults[i]));
                    AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(TNumeric(abs(FreeMember)), Temp)));
                }
                AddLine(Lines, Ntabs, new TText ((*Phrases)[PhFactorizeMajorTerm]));
                Temp.Operands.clear();
                if(MajorMemberMults.size()==1)
                    AddLine(Lines, Ntabs+1, new TLine(new TNumeric(abs(MajorMember)), new TText((*Phrases)[PhIsSimpleNumber])));
                else {
                    for(size_t i = 0; i < MajorMemberMults.size(); i++) Temp.Operands.push_back(TNumeric(MajorMemberMults[i]));
                        AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(TNumeric(abs(MajorMember)), Temp)));
                };
            }
            AddLine(Lines, Ntabs, new TText ((*Phrases)[PhCheckingRoots]));
                if(find(FreeMemberMults.begin(), FreeMemberMults.end(), 1) == FreeMemberMults.end()) FreeMemberMults.push_back(1); //если небыло единицы среди множителей, добавляем её
            if(find(MajorMemberMults.begin(), MajorMemberMults.end(), 1) == MajorMemberMults.end()) MajorMemberMults.push_back(1); //если небыло единицы среди множителей, добавляем её
            vector<int> FreeProds = GetAllProds(FreeMemberMults);
            vector<int> MajorProds = GetAllProds(MajorMemberMults);
            for(size_t i = 0; i < FreeProds.size(); i++) //перебираем делители свободного члена
                for(size_t j = 0; j < MajorProds.size(); j++) //перебираем делители коэф при старшем члене
                    for(int sign = -1; sign <=1; sign+=2) //перебераем знак
                    {
                        TNumeric Test; //тестовый корень
                        int N = FreeProds[i];
                            int D = MajorProds[j];
                        if(D == 1)
                        {
                            Test = TNumeric(sign*N);
                            } else {
                            Test.Operator = OperatorFrac;
                                Test.Operands.clear();
                            Test.Operands.push_back(sign*N);
                            Test.Operands.push_back(D);
                            };
                        bool AllreadyFound = false;
                        Test = Test.Simplify();
                        for(size_t r = 0; r < RationalRoots.size(); r++)
                        {
                            if(RationalRoots[r] == Test) //Для левой и правой части метод Simplify уже вызывался
                            {
                                AllreadyFound = true;
                                break;
                            }
                        }
                        if(AllreadyFound == false)
                            //проверяем тестовый корень
                            if(P.Calculate(Test) == 0)
                            {
                                AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(UnknownVar, Test)));
                                RationalRoots.push_back(Test);
                            };
                    }
             if(RationalRoots.size() == 0)
            {
                AddLine(Lines, Ntabs+1, new TText ((*Phrases)[PhNoRationalRoots]));
                //todo: Хорошо бы доказать, что многочлен  PRemaining корней не имеет, если это возможно (x^2+1, например, всегда больше нуля)
                return false;
            }
            else {
                AddLine(Lines, Ntabs, new TText ((*Phrases)[PhCheckingRootsMultiplicity]));
                TNumeric Res; //разложение на множители
                Res.Operator = OperatorProd;
                TPolynom PRemaining = P;
                for(size_t i = 0; i < RationalRoots.size(); i++)
                {
                    vector<TNumeric> Divisor;
                    //устанавливаем делитель в x - RationalRoots[i]
                    Divisor.assign(2, TNumeric(0));
                    Divisor[0] = (RationalRoots[i]*TNumeric(-1)).Simplify();
                    Divisor[1] = TNumeric(1);

                    TPolynom Reminder;
                    TPolynom PRemainingPrev = PRemaining;
                    int Multiplicity = 0; //кратность корня
                    do
                    {
                        TPolynom Ratio = PRemaining.Div(Divisor, &Reminder);
                        if(Reminder.MajorPower() == 0 && Reminder.GetCoef(0) == 0)
                            //делится без остатка
                        {
                            Multiplicity++;
                            PRemaining = Ratio;
                        }
                        else break;
                    }while(true);

                    if(Multiplicity > 0)
                    {
                        TNumeric Multiplier;
                        Multiplier.Operator = OperatorSum;
                        Multiplier.Operands.push_back(UnknownVar);
                        Multiplier.Operands.push_back((TNumeric(-1)*TNumeric(RationalRoots[i])).Simplify());
                        if(Multiplicity > 1)
                        {
                            TNumeric Temp = Multiplier;
                            Multiplier.Operands[0] = Temp;
                            Multiplier.Operands[1] = TNumeric(Multiplicity);
                            Multiplier.Operator = OperatorPow;
                        };
                        AddLine(Lines, Ntabs, new TNumeric(MakeEquality(PRemainingPrev.GetNumeric(UnknownVar), Multiplier*PRemaining.GetNumeric(UnknownVar))));

                        //Добавляем найденный корень к результатам
                        Res.Operands.push_back(Multiplier);
                        Roots.push_back(RationalRoots[i]);
                        RootsMultiplicity.push_back(Multiplicity);
                        Result = Result + TInterval(RationalRoots[i]);
                    };
                };


                if(PRemaining.MajorPower() > 0 || PRemaining.GetCoef(0) != 1)
                    Res = Res*PRemaining.GetNumeric(UnknownVar);

                switch(PRemaining.MajorPower())
                {
                    case 0: break;
                    case 1: //остался многочлен первой степени
                    {
                        TLinearEquality Eq(PRemaining);
                        AddLine(Lines, Ntabs, new TLine(new TText ((*Phrases)[PhSolvingLinearEquality]), new TNumeric(*Eq.Conditions)));
                        Eq.GetSolution(Lines, Ntabs+1);
                        Result = Result + Eq.Result;
                        Roots.insert(Roots.end(), Eq.Roots.begin(), Eq.Roots.end());
                        RootsMultiplicity.insert(RootsMultiplicity.end(), Eq.RootsMultiplicity.begin(), Eq.RootsMultiplicity.end());
                        if(Eq.Degenerate)Degenerate = true;
                    }
                    break;
                    case 2: //остался многочлен второй степени
                    {
                        TSquareEquality Eq(PRemaining);
                        AddLine(Lines, Ntabs, new TLine(new TText ((*Phrases)[PhSolvingSquareEquality]), new TNumeric(*Eq.Conditions)));
                        Eq.GetSolution(Lines, Ntabs+1);
                        Result = Result + Eq.Result;
                        Roots.insert(Roots.end(), Eq.Roots.begin(), Eq.Roots.end());
                        RootsMultiplicity.insert(RootsMultiplicity.end(), Eq.RootsMultiplicity.begin(), Eq.RootsMultiplicity.end());
                        if(Eq.Degenerate)Degenerate = true;
                    }
                    break;
                    default: //остался многочлен третьей или более высокой степени
                        //todo: Хорошо бы доказать, что многочлен  PRemaining корней не имеет, если это возможно (x^2+1, например, всегда больше нуля)
                        AddLine(Lines, Ntabs, new TText((*Phrases)[PhErrorCantFindRootsOfRemainingPolynom]));
                        return false;
                    break;
                }

                AddLine(Lines, Ntabs, new TText ((*Phrases)[PhFoundRoots]));
                AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, Result.GetNumeric())));
            }
        };
    };
    SortRoots();
    return true;
}

void TPolynomialEquality::SortRoots()
{
    for(size_t i = 1; i < Roots.size(); i++)
        for(size_t j = 0; j < i; j++)
        {
            if(Roots[i].Calculate() < Roots[j].Calculate())
            {
                TNumeric T = Roots[i];
                Roots[i] = Roots[j];
                Roots[j] = T;

                size_t Mult = RootsMultiplicity[i];
                RootsMultiplicity[i] = RootsMultiplicity[j];
                RootsMultiplicity[j] = Mult;
            }
        }
}


//********************************************************************************************************
//********************************************************************************************************

TLinearEquality::TLinearEquality() : TPolynomialEquality(1)
{
}

TLinearEquality::TLinearEquality(const TPolynom& P) : TPolynomialEquality(P, false)
{
    if(P.MajorPower() > 1)  throw "TLinearEquality::TLinearEquality(TPolynom P): P.MajorPower() > 1";
}


TLinearEquality::~TLinearEquality()
{
//delete Conditions and delete Solution is called by ~TProblem, no need to call them here
}

/*TLinearEquality::TLinearEquality(const TLinearEquality& L) : TEquality()
{
    Assign(L);
}*/


string TLinearEquality::GetTask()
{
    return (*Phrases)[PhSolveLinearEquality];
}

string TLinearEquality::GetShortTask()
{
    return (*Phrases)[PhLinearEquality];
}

void TLinearEquality::Assign(const TLinearEquality& L)
{
    if(Conditions == 0) Conditions = new TNumeric;
    *Conditions = *L.Conditions;

    if(Solution) delete Solution;
    Solution = 0;
    //Solution не копируем, так как объеты типа TLines вообще копировать нельзя (они содержат массивы указателей)

}


void TLinearEquality::SetLeftPartP(const TPolynom &P)
{
TPolynom P2 = P;
    if(P2.MajorPower() > 1) throw "TLinearEquality::SetLeftPart(const TPolynom &P): MajorPower > 1";
    while(P2.Coef.size() < 2) P2.Coef.push_back(TNumeric(0)); //требуем, чтобы все необходимые коэффициенты присутствовали
    TPolynomialEquality::SetLeftPartP(P2);
}

bool TLinearEquality::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
    TNumeric* a = GetCoefP(1);
    TNumeric* b = GetCoefP(0);
    TNumeric* c = GetRightPartP();
    if(a == 0 || b == 0 || c == 0)
    {
       AddLine(Lines, Ntabs, new TText("Error: can't find coefficients"));
       return false;
    };
    Result.Intervals.clear();

    if(!(a->CanCalculate() && b->CanCalculate() && c->CanCalculate())) return false;
    if(a->Calculate() == 0)
    {
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhMajorCoefIsZero]));
        Degenerate = true;
        Roots.clear();
        RootsMultiplicity.clear();
        if((*c-(*b)).Calculate() == 0)
        {            
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhSolutionIsAnyNumber]));
            AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
            Result.Intervals.push_back(IntervalAllRealNumbers);
        } else {
            AddLine(Lines, Ntabs, new TLine(new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)), new TText((*Phrases)[PhNoSolution])));
            Result.Intervals.clear();
        }
    } else {
        TNumeric X = ((*c)-(*b))/(*a);
        TNumeric XSimplified = X.Simplify();
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhOnlySolutionExists]));
        AddLine(Lines, Ntabs, new TNumeric(MakeEquality(UnknownVar, MakeEquality(X, XSimplified))));
        Result.Intervals.push_back(TInterval(XSimplified, XSimplified, true, true));
        Degenerate = false;
        Roots.clear();
        Roots.push_back(XSimplified);
        RootsMultiplicity.push_back(1);
    };
    SortRoots();
    return true;
 };

//********************************************************************************************************
//********************************************************************************************************

TSquareEquality::TSquareEquality() : TPolynomialEquality(2)
{
}

TSquareEquality::TSquareEquality(TPolynom P) : TPolynomialEquality(P, false)
{
    if(P.MajorPower() > 2)  throw "TSquareEquality::TSquareEquality(TPolynom P): P.MajorPower() > 2";
}

TSquareEquality::~TSquareEquality()
{
//delete Conditions and delete Solution is called by ~TProblem, no need to call them here
}


string TSquareEquality::GetTask()
{
    return (*Phrases)[PhFindAllRealRootsOfSquareEquality];
}

string TSquareEquality::GetShortTask()
{
    return (*Phrases)[PhSquareEquality];
}

void TSquareEquality::SetLeftPartP(const TPolynom &P)
{
TPolynom P2 = P;
    if(P2.MajorPower() > 2) throw "TSquareEquality::SetLeftPartP(const TPolynom &P): MajorPower > 2";
    while(P2.Coef.size() < 3) P2.Coef.push_back(TNumeric(0)); //требуем, чтобы все необходимые коэффициенты присутствовали
    TPolynomialEquality::SetLeftPartP(P2);
}

bool TSquareEquality::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
    TNumeric *a = GetCoefP(2);
    TNumeric *b = GetCoefP(1);
    TNumeric *c = GetCoefP(0);
    if(a == 0 || b == 0 || c == 0)
    {
       AddLine(Lines, Ntabs, new TText("Error: can't find coefficients"));
       return false;
    };
    if(!(a->CanCalculate() && b->CanCalculate() && c->CanCalculate())) return false;

    Result.Intervals.clear();
    Roots.clear();
    RootsMultiplicity.clear();

    TNumeric X;
        if(a->Calculate() == 0)
        {
            //решаем линейное уравнение
            TLinearEquality E;
            E.SetLeftPart(*b, *c);
            vector<TRectangleElement*> L;
            E.GetSolution(&L, Ntabs + 1);
            if(Lines)
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhSquareCoefIsZeroConseqLinear]));
                Lines->insert(Lines->end(), L.begin(), L.end());
            };
            //копируем ответ
            Result = E.Result;
            Degenerate = E.Degenerate;
            Roots = E.Roots;
            RootsMultiplicity = E.RootsMultiplicity;
        } else {
            if(c->Calculate() == 0)
            {
                //случай ax^2+bx = 0, возможно b = 0
                TNumeric X1("0");
                if(b->Calculate() == 0)
                //случай ax^2 = 0
                {
                    AddLine(Lines, Ntabs, new TText((*Phrases)[PhEqualityHasOneRootOfTwiceMult]));
                    AddLine(Lines, Ntabs, new TNumeric(MakeEquality(UnknownVar, X1)));
                    Result.Intervals.push_back(TInterval(X1, X1, true, true));
                    Degenerate = false;
                    Roots.push_back(X1);
                    RootsMultiplicity.push_back(2);
                } else {
                    //случай ax^2+bx = 0
                    TNumeric X2(-(*b)/(*a));
                    TNumeric X2Simplified = X2.Simplify();
                    AddLine(Lines, Ntabs, new TText((*Phrases)[PhEqualityHasTwoDifferentRoots]));
                    AddLine(Lines, Ntabs, new TNumeric(MakeEquality(X_1, X1)));
                    AddLine(Lines, Ntabs, new TNumeric(MakeEquality(X_2, MakeEquality(X2, X2Simplified))));
                    Result.Intervals.push_back(TInterval(X1, X1, true, true));
                    Result.Intervals.push_back(TInterval(X2Simplified, X2Simplified, true, true));
                    Degenerate = false;
                    Roots.push_back(X1);
                    Roots.push_back(X2Simplified);
                    RootsMultiplicity.push_back(1);
                    RootsMultiplicity.push_back(1);
                }

            } else {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhFindingDiscriminant]));
                TNumeric D = ((*b)^TNumeric(2)) - TNumeric(4) * (*a) * (*c);
                TNumeric DSimplified = D.Simplify();
                AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(TNumeric("D"), MakeEquality(D, DSimplified))));

                double d = DSimplified.Calculate();

                if(d == 0)
                {
                    AddLine(Lines, Ntabs, new TText((*Phrases)[PhDIsZero]));
                    TNumeric X1 = (-(*b)+DSimplified.sqrt())/(TNumeric(2)*(*a));
                    TNumeric X1Simplified = X1.Simplify();
                    AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(UnknownVar, MakeEquality(X1, X1Simplified))));
                    Result.Intervals.push_back(TInterval(X1Simplified, X1Simplified, true, true));
                    Degenerate = false;
                    Roots.push_back(X1Simplified);
                    RootsMultiplicity.push_back(2);
                } else {
                    if(d > 0)
                    {
                        AddLine(Lines, Ntabs, new TText((*Phrases)[PhDIsGreaterThanZero]));

                        TNumeric X1 = (-(*b)+DSimplified.sqrt())/(TNumeric(2)*(*a));
                        TNumeric X1Simplified = X1.Simplify();
                        AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(X_1, MakeEquality(X1, X1Simplified))));
                        Result.Intervals.push_back(TInterval(X1Simplified, X1Simplified, true, true));


                        TNumeric X2 = (-(*b)-DSimplified.sqrt())/(TNumeric(2)*(*a));
                        TNumeric X2Simplified = X2.Simplify();
                        AddLine(Lines, Ntabs+1, new TNumeric(MakeEquality(X_2, MakeEquality(X2, X2Simplified))));
                        Result.Intervals.push_back(TInterval(X2Simplified, X2Simplified, true, true));

                        Degenerate = false;
                        Roots.push_back(X1Simplified);
                        Roots.push_back(X2Simplified);
                        RootsMultiplicity.push_back(1);
                        RootsMultiplicity.push_back(1);
                    } else {
                        AddLine(Lines, Ntabs, new TText((*Phrases)[PhDIsLessThanZero]));
                        Result.Intervals.clear();
                        Degenerate = false; //вырожденным не является, просто нет корней
                        Roots.clear();
                        RootsMultiplicity.clear();
                    }
                };
            };
        };
        SortRoots();
        return true;
}

//*****************************************************************************************************************************
//              НЕРАВЕНСТВА
//*****************************************************************************************************************************
TPolynomialInequality::TPolynomialInequality(size_t MaxPower, bool Less, bool Strict) : TPolynomConditions(MaxPower, OperatorLess)
{
    SetType(Less, Strict);
}

TPolynomialInequality::TPolynomialInequality(const TPolynom& P, bool Less, bool Strict, bool AllCoef) : TPolynomConditions(P, OperatorLess, AllCoef)
{
    SetType(Less, Strict);
}

TPolynomialInequality::~TPolynomialInequality()
{

}

bool TPolynomialInequality::SetType(bool Less, bool Strict)
{
int Operator;
    if(Less && Strict) Operator = OperatorLess;
    if(Less && !Strict) Operator = OperatorLessOrEqual;
    if(!Less && Strict) Operator = OperatorGreater;
    if(!Less && !Strict) Operator = OperatorGreaterOrEqual;
    Conditions->Operator = Operator;
    this->Less = Less;
    this->Strict = Strict;
}


string TPolynomialInequality::GetTask()
{
    return Phrases->sprintf(PhSolveInequalityOfNthPower, MaxPower);
}

string TPolynomialInequality::GetShortTask()
{
    return Phrases->sprintf(PhInequalityOfNthPower, MaxPower);
}

bool TPolynomialInequality::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
vector<TNumeric> Coef1; //коэффициенты в виде объектов TNumeric
    Coef1 = GetCoef();

    Result.Intervals.clear();
    TPolynom P(Coef1);

TPolynomialEquality E(P);
    AddLine(Lines, Ntabs, new TText((*Phrases)[PhFindingRootsOfPolynom]));
    if(E.GetSolution(Lines, Ntabs+1))
    {
        if(E.Degenerate)
        {
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhLeftSideIsDegenerated]));
            if(Strict)
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhBecauseTheInequalityIsStrictNoSolution]));
                Result.Intervals.clear();
            }
            else
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhBecauseTheInequalityIsUnstrictAnySolution]));
                Result = E.Result;
            }
        } else {
            size_t MajorPower = P.MajorPower();

            int CurSign; //текущий знак
            int LeaderTermSign;
            if(P.GetCoef(MajorPower).Calculate() < 0) LeaderTermSign = -1;
            else LeaderTermSign = +1;
            if(MajorPower % 2 == 0) CurSign = LeaderTermSign; //четная степень
            else
            {
                if(P.GetCoef(MajorPower).Calculate() < 0) CurSign = LeaderTermSign; //-x^3 > 0 при x = -inf
                else CurSign = -LeaderTermSign; //x^3 < 0 при x = -inf
            };

            TNumeric LeftX = NumericMinusInf;
            bool IncludeLeft = false;
            for(size_t i = 0; i <= E.Roots.size(); i++)
            {
                TNumeric RightX;
                bool IncludeRight;
                if(i < E.Roots.size())
                {
                    RightX = E.Roots[i];
                    IncludeRight = !Strict;
                }
                else
                {
                    RightX = NumericPlusInf;
                    IncludeRight = false;
                };

                bool Include = false; //итсина, если многочлен на текущем сегменте LeftX..RightX удовлетворяет неравенству
                if(Less && CurSign == -1)Include = true;
                if(!Less && CurSign == 1)Include = true;
                if(Include)
                    Result = Result + TInterval(LeftX, RightX, IncludeLeft, IncludeRight);

                //переходим к следующему участку
                if(E.RootsMultiplicity[i] % 2 == 1) CurSign = -CurSign;
                LeftX = RightX;
                IncludeLeft = IncludeRight;
            }
        }
    } else {
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhErrorCantFindRoots]));
    }
    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, Result.GetNumeric())));
}

vector<TNumeric> TPolynomialInequality::GetTypes(TNumeric* N)
{
vector<TNumeric> Types;
    if(N != Conditions) return Types;
    Types.push_back(TNumeric(*TPolynomialInequality(GetP(), false, false).Conditions));
    Types.push_back(TNumeric(*TPolynomialInequality(GetP(), true, false).Conditions));
    Types.push_back(TNumeric(*TPolynomialInequality(GetP(), false, true).Conditions));
    Types.push_back(TNumeric(*TPolynomialInequality(GetP(), true, true).Conditions));
    return Types;
}

void TPolynomialInequality::SetType(TNumeric* N, size_t Type)
{
    if(N == Conditions) //Проверяем, чтобы клик был по всему уравнению
    {
        switch(Type)
        {
            case 0: SetType(false, false); break;
            case 1: SetType(true, false); break;
            case 2: SetType(false, true); break;
            case 3: SetType(false, true); break;
            default: break;
        }
    }
}

void TPolynomialInequality::SaveToFile(ofstream &f)
{
    f.write((char*)&Strict, sizeof(Strict));
    f.write((char*)&Less, sizeof(Less));
    TPolynomConditions::SaveToFile(f);
}

void TPolynomialInequality::LoadFromFile(ifstream &f)
{
    f.read((char*)&Strict, sizeof(Strict));
    f.read((char*)&Less, sizeof(Less));
    TPolynomConditions::LoadFromFile(f);
}




//*****************************************************************************************************************************
//*****************************************************************************************************************************
TLinearInequality::TLinearInequality(bool Less, bool Strict) : TPolynomialInequality(1, Less, Strict)
{
}

TLinearInequality::TLinearInequality(const TLinearInequality *L, bool Less, bool Strict) : TPolynomialInequality(L->GetP(), Less, Strict)
{
}

TLinearInequality::~TLinearInequality()
{

}

string TLinearInequality::GetTask()
{
    if(Strict)
        return (*Phrases)[PhSolveStrictLinearInequality];
    else
        return (*Phrases)[PhSolveUnstrictLinearInequality];
}

string TLinearInequality::GetShortTask()
{
    return (*Phrases)[PhSolveLinearInequality];
}


bool TLinearInequality::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
    TNumeric* a = GetCoefP(1);
    TNumeric* b = GetCoefP(0);
    TNumeric* c = GetRightPartP();
    Result.Intervals.clear();
    if(a == 0 || b == 0 || c == 0)
    {
       AddLine(Lines, Ntabs, new TText("Error: can't find coefficients"));
       return false;
    };

    if(!(a->CanCalculate() && b->CanCalculate() && c->CanCalculate())) return false;

    Result.Intervals.clear();

    if((Less && a->Calculate() > 0) || (!Less && a->Calculate()<0))
    {
        TNumeric X = (*c - (*b))/(*a);
        TNumeric XSimplified = X.Simplify();
        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeInterval(NumericMinusInf, XSimplified, false, !Strict))));
        Result.Intervals.push_back(TInterval(NumericMinusInf, XSimplified, false, !Strict));
    };
    if((Less && a->Calculate() < 0) || (!Less && a->Calculate()>0))
    {
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhCoefXisLessThanZeroSoSignIsChanged]));
        TNumeric X = (*c - (*b))/(*a);
        TNumeric XSimplified = X.Simplify();
        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeInterval(XSimplified, NumericPlusInf, !Strict, false))));
        Result.Intervals.push_back(TInterval(XSimplified, NumericPlusInf, !Strict, false));
    };

    if(a->Calculate() == 0)
    {
        //прямая горизонтальна
        if((Less && b->Calculate() < c->Calculate()) || (!Less && b->Calculate() > c->Calculate()) || (b->Calculate() == c->Calculate() && !Strict))
        {
            AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeInterval(NumericMinusInf, NumericPlusInf))));
            Result.Intervals.push_back(TInterval(NumericMinusInf, NumericPlusInf, false, false));
        }
        else
        {
            AddLine(Lines, Ntabs, new TLine(new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)), new TText((*Phrases)[PhNoSolution])));
            Result.Intervals.clear();
        }
    }
    return true;
}

/*vector<TNumeric> TLinearInequality::GetTypes(TNumeric* N)
{
vector<TNumeric> Types;
    if(N != Conditions) return Types;
    Types.push_back(TNumeric(*TLinearInequality(this, false, false).Conditions));
    Types.push_back(TNumeric(*TLinearInequality(this, true, false).Conditions));
    Types.push_back(TNumeric(*TLinearInequality(this, false, true).Conditions));
    Types.push_back(TNumeric(*TLinearInequality(this, true, true).Conditions));
    return Types;
}

void TLinearInequality::SetType(TNumeric* N, size_t Type)
{
    if(N == Conditions)
    {
        switch(Type)
        {
            case 0: Less = false; Strict = false; Conditions->Operator = OperatorGreaterOrEqual; break;
            case 1: Less = true;  Strict = false; Conditions->Operator = OperatorLessOrEqual; break;
            case 2: Less = false; Strict = true;  Conditions->Operator = OperatorGreater; break;
            case 3: Less = true;  Strict = true;  Conditions->Operator = OperatorLess; break;
            default: break;
        }
    }
}*/

//**************************************************************************************
//**************************************************************************************
TSquareInequality::TSquareInequality(bool Less, bool Strict) : TPolynomialInequality(2, Less, Strict)
{
}

TSquareInequality::TSquareInequality(const TSquareInequality *L, bool Less, bool Strict) : TPolynomialInequality(L->GetP(), Less, Strict)
{
}

TSquareInequality::~TSquareInequality()
{
}

string TSquareInequality::GetTask()
{
    return (*Phrases)[PhSolveSquareInequality];
}

string TSquareInequality::GetShortTask()
{
    return (*Phrases)[PhSquareInequality];
}

/*void TSquareInequality::SetCoef(const TNumeric& a, const TNumeric &b, const TNumeric &c)
{
    TNumeric* a1 = Conditions->GetByID(IDa);
    TNumeric* b1 = Conditions->GetByID(IDb);
    TNumeric* c1 = Conditions->GetByID(IDc);
    *(a1) = a;
    *(b1) = b;
    *(c1) = c;
}*/

bool TSquareInequality::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
TSquareEquality Eq;
    TNumeric *a = GetCoefP(2);
    TNumeric *b = GetCoefP(1);
    TNumeric *c = GetCoefP(0);
    if(a == 0 || b == 0 || c == 0)
    {
       AddLine(Lines, Ntabs, new TText("Error: can't find coefficients"));
       return false;
    };
    if(!(a->CanCalculate() && b->CanCalculate() && c->CanCalculate())) return false;

    if(!(a->CanCalculate() && b->CanCalculate() && c->CanCalculate())) return false;

    Result.Intervals.clear();

    if(a->Calculate() == 0)
    {
        //вырожденное квадратное уравнение
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhAisZeroEqualityIsDegenerated]));
        if(b->Calculate() == 0)
        {
            //корней нет, то есть прямая горизонтальна
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhBisZeroConsequentlyHorizLine]));
            if(c->Calculate() < 0)
            {
                //прямая ниже оси X
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhCisLessThanZeroLineIsBelowX]));
                if(Less)
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
                    Result.Intervals.push_back(IntervalAllRealNumbers);
                }
                else
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)));
                    Result.Intervals.clear();
                }
            };
            if(c->Calculate() == 0)
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhCisZeroLineCoincideWithX]));
                if(Strict)
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)));
                    Result.Intervals.clear();
                }
                else
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
                    Result.Intervals.push_back(IntervalAllRealNumbers);
                }
            }
            if(c->Calculate() > 0)
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhCisGreaterThanZeroLineIsAboveX]));
                if(Less)
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)));
                    Result.Intervals.clear();
                }
                else
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
                    Result.Intervals.push_back(IntervalAllRealNumbers);
                }
            }
        };
        if(b->Calculate() > 0)
        {
            //должен быть один корень
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhBisNotEqualToZeroOnlyRootExists]));
            TNumeric X = TNumeric("-1")*(*c)/(*b);
            TNumeric XSimplified = X.Simplify();
            AddLine(Lines, Ntabs, new TNumeric(MakeEquality(UnknownVar, XSimplified)));
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhBisGreaterThanZero]));
            if(Less)
            {
                AddLine(Lines, Ntabs, new TNumeric(MakeInterval(NumericMinusInf, XSimplified, false, !Strict)));
                Result.Intervals.push_back(TInterval(NumericMinusInf, XSimplified, false, !Strict));
            }
            else
            {
                AddLine(Lines, Ntabs, new TNumeric(MakeInterval(XSimplified, NumericPlusInf, !Strict, false)));
                Result.Intervals.push_back(TInterval(XSimplified, NumericMinusInf, !Strict, false));
            }

        };
        if(b->Calculate() < 0)
        {
            //должен быть один корень
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhBisGreaterThanZeroOnlyRootExists]));
            TNumeric X = TNumeric("-1")*(*c)/(*b);
            TNumeric XSimplified = X.Simplify();
            AddLine(Lines, Ntabs, new TNumeric(MakeEquality(UnknownVar, XSimplified)));
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhBisLessThanZero]));
            if(Less)
            {
                AddLine(Lines, Ntabs, new TNumeric(MakeInterval(XSimplified, NumericPlusInf, !Strict, false)));
                Result.Intervals.push_back(TInterval(XSimplified, NumericMinusInf, !Strict, false));
            }
            else
            {
                AddLine(Lines, Ntabs, new TNumeric(MakeInterval(NumericMinusInf, XSimplified, false, !Strict)));
                Result.Intervals.push_back(TInterval(NumericMinusInf, XSimplified, false, !Strict));
            }
        };
    } else {
        TSquareEquality Eq;
        Eq.SetLeftPart(*a, *b, *c);
        TIntervalsSet Roots;

        AddLine(Lines, Ntabs, new TText((*Phrases)[PhFindingRootsOfSquareEquality]));
        Eq.GetSolution(Lines, Ntabs + 1);
        Roots = Eq.Result;

        if(Roots.Intervals.size() == 0)
        {
            //корней нет
            if(a->Calculate() < 0)
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhAisLessThanZeroParabolaBranchesDown]));
                if(Less)
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
                    Result.Intervals.push_back(IntervalAllRealNumbers);
                }
                else
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)));
                    Result.Intervals.clear();
                }
            } else {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhAisGreaterThanZeroParabolaBranchesUp]));
                if(Less)
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)));
                    Result.Intervals.clear();
                }
                else
                {
                    AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
                    Result.Intervals.push_back(IntervalAllRealNumbers);
                }
            };
        };
        if(Roots.Intervals.size() == 1)
        {
            //один корень
            AddLine(Lines, Ntabs, new TText((*Phrases)[PhParabolaIntersectsXatOnlyPoint]));
            TNumeric X = Roots.Intervals[0].Left;

            if(a->Calculate() < 0)
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhAisLessThanZeroParabolaBranchesDown]));
                if(Less)
                    if(Strict)
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeUnion(MakeInterval(NumericMinusInf, TNumeric(X), false, !Strict), MakeInterval(TNumeric(X), NumericPlusInf, false, false)))));
                        Result.Intervals.push_back(TInterval(NumericMinusInf, X, false, !Strict));
                    }
                    else
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
                        Result.Intervals.push_back(TInterval(NumericMinusInf, NumericPlusInf));
                    }
                else
                    if(Strict)
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)));
                        Result.Intervals.clear();
                    }
                    else
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeInline(TNumeric("{"), X, TNumeric("}")))));
                        Result.Intervals.push_back(TInterval(X, X, !Strict, !Strict));
                    }

            } else {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhAisGreaterThanZeroParabolaBranchesUp]));
                if(Less)
                    if(Strict)
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, EmptySet)));
                        Result.Intervals.clear();
                    }
                    else
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeInline(TNumeric("{"), X, TNumeric("}")))));
                        Result.Intervals.push_back(TInterval(X, X, !Strict, !Strict));
                    }
                else
                    if(Strict)
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeUnion(MakeInterval(NumericMinusInf, TNumeric(X), false, !Strict), MakeInterval(TNumeric(X), NumericPlusInf, false, false)))));
                        Result.Intervals.push_back(TInterval(NumericMinusInf, X, false, !Strict));
                        Result.Intervals.push_back(TInterval(X, NumericPlusInf, !Strict, false));
                    }
                    else
                    {
                        AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, NumericAllReal)));
                        Result.Intervals.push_back(TInterval(NumericMinusInf, NumericPlusInf));
                    }
            };
        };
        if(Roots.Intervals.size() == 2)
        {
            //два корня
            TNumeric X1 = Roots.Intervals[0].Left;
            TNumeric X2 = Roots.Intervals[1].Left;
            if(X1.Calculate() > X2.Calculate())
            {
                TNumeric T = X1;
                X1 = X2;
                X2 = T;
            }

            if(a->Calculate()<0)
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhAisLessThanZeroParabolaBranchesDown]));
            }
            else
            {
                AddLine(Lines, Ntabs, new TText((*Phrases)[PhAisGreaterThanZeroParabolaBranchesUp]));
            }
            if((Less && a->Calculate() < 0) || (!Less && a->Calculate()>0))
            {
                AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeUnion(MakeInterval(NumericMinusInf, TNumeric(X1), false, !Strict), MakeInterval(TNumeric(X2), NumericPlusInf, !Strict, false)))));
                Result.Intervals.push_back(TInterval(NumericMinusInf, X1, false, !Strict));
                Result.Intervals.push_back(TInterval(X2, NumericMinusInf, !Strict, false));
            } else {
                AddLine(Lines, Ntabs, new TNumeric(MakeBelongsTo(UnknownVar, MakeInterval(X1, X2, !Strict, !Strict))));
                Result.Intervals.push_back(TInterval(X1, X2, !Strict, !Strict));
            };
        };
    }
    return true;
}


/*vector<TNumeric> TSquareInequality::GetTypes(TNumeric* N)
{
vector<TNumeric> Types;
    if(N != Conditions) return Types;
    Types.push_back(TNumeric(*TSquareInequality(this, false, false).Conditions));
    Types.push_back(TNumeric(*TSquareInequality(this, true, false).Conditions));
    Types.push_back(TNumeric(*TSquareInequality(this, false, true).Conditions));
    Types.push_back(TNumeric(*TSquareInequality(this, true, true).Conditions));
    return Types;
}

void TSquareInequality::SetType(TNumeric* N, size_t Type)
{
    if(N == Conditions)
    {
        switch(Type)
        {
            case 0: Less = false; Strict = false; Conditions->Operator = OperatorGreaterOrEqual; break;
            case 1: Less = true;  Strict = false; Conditions->Operator = OperatorLessOrEqual; break;
            case 2: Less = false; Strict = true;  Conditions->Operator = OperatorGreater; break;
            case 3: Less = true;  Strict = true;  Conditions->Operator = OperatorLess; break;
            default: break;
        }
    }
}*/
//*****************************************************************************************************************************

TPolynomDerivative::TPolynomDerivative(size_t MaxPower) : TPolynomConditions(MaxPower, false)
{

}
TPolynomDerivative::~TPolynomDerivative()
{

}

string TPolynomDerivative::GetTask()
{
    return Phrases->sprintf(PhFindDerivativeOfPolynom, MaxPower);
}

string TPolynomDerivative::GetShortTask()
{
    return Phrases->sprintf(PhPolynomOfDPower, MaxPower);
}

bool TPolynomDerivative::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
    TPolynom P = GetP();
    if(Lines)
    {
        TPolynom D = P.Derivative();
        TPolynom DSimplified = D;
        for(size_t i = 0; i < DSimplified.Coef.size(); i++) DSimplified.Coef[i] = DSimplified.Coef[i].Simplify();
        TNumeric dP;
        dP.Operator = OperatorDeriv;
        dP.Operands.push_back(P.GetNumeric());
        AddLine(Lines, Ntabs, new TNumeric(MakeEquality(dP, TNumeric(" "))));
        AddLine(Lines, Ntabs, new TNumeric(MakeEquality(D.GetNumeric(), TNumeric(" "))));
        AddLine(Lines, Ntabs, new TNumeric(DSimplified.GetNumeric()));
    }
    return true;
}

//*****************************************************************************************************************************

TRationalFunctionDerivative::TRationalFunctionDerivative(size_t MaxPowerNominator, size_t MaxPowerDenominator)
{
    this->MaxPowerNominator = MaxPowerNominator;
    this->MaxPowerDenominator = MaxPowerDenominator;
    UnknownVar = TNumeric("x");

    TNumeric Nominator;
    Nominator.Operator = OperatorSum;
    for(size_t i = 0; i <= MaxPowerNominator; i++)
    {
        TNumeric a(0);
        a.ClearID();
        a.ID = i;
        a.SetEditable(true);
        if(i == 0)
        {
            Nominator = a;
        } else {
            TNumeric Temp = a*(UnknownVar^TNumeric(i));
            Nominator = Temp + Nominator;
        }
    }

    TNumeric Denominator;
    Denominator.Operator = OperatorSum;
    for(size_t i = 0; i <= MaxPowerDenominator; i++)
    {
        TNumeric a(0);
        a.ClearID();
        a.ID = MaxPowerNominator + 1 + i;
        a.SetEditable(true);
        if(i == 0)
        {
            a.K = "1";
            Denominator = a;
        } else {
            TNumeric Temp = a*(UnknownVar^TNumeric(i));
            Denominator = Temp + Denominator;
        }
    }
    TNumeric Res;
    Res.Operator = OperatorFrac;
    Res.Operands.push_back(Nominator);
    Res.Operands.push_back(Denominator);

    Conditions = new TNumeric(Res);
}
TRationalFunctionDerivative::~TRationalFunctionDerivative()
{

}

string TRationalFunctionDerivative::GetTask()
{
    return (*Phrases)[PhFindDerivativeOfRationalFunction];
}

string TRationalFunctionDerivative::GetShortTask()
{
    return Phrases->sprintf(PhRationalFunctionOfNDPowers, MaxPowerNominator, MaxPowerDenominator);
}

bool TRationalFunctionDerivative::GetSolution(vector<TRectangleElement*> *Lines, size_t Ntabs)
{
    TRationalFunction R;
    R.P.Coef.assign(MaxPowerNominator+1, TNumeric(0));
    for(size_t i = 0; i <= MaxPowerNominator; i++)
    {
        TNumeric *N = Conditions->GetByID(i);
        if(N == 0)
            return false;
        else
            R.P.Coef[i] = *N;
    }
    R.Q.Coef.assign(MaxPowerDenominator+1, TNumeric(0));
    for(size_t i = 0; i <= MaxPowerDenominator; i++)
    {
        TNumeric *N = Conditions->GetByID(i+MaxPowerNominator+1);
        if(N == 0)
            return false;
        else
            R.Q.Coef[i] = *N;
    }
    if(Lines)
    {
        TRationalFunction D = R.Derivative();
        TRationalFunction DSimplified = D;
        for(size_t i = 0; i < DSimplified.P.Coef.size(); i++) DSimplified.P.Coef[i] = DSimplified.P.Coef[i].Simplify();
        for(size_t i = 0; i < DSimplified.Q.Coef.size(); i++) DSimplified.Q.Coef[i] = DSimplified.Q.Coef[i].Simplify();
        TNumeric dP;
        TNumeric MainAndO;
        dP.Operator = OperatorDeriv;
        dP.Operands.push_back(R.GetNumeric());
        MainAndO = DSimplified.GetMainPartAndO();
        AddLine(Lines, Ntabs, new TNumeric(MakeEquality(dP, TNumeric(" "))));
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhFindingDerivativeOfFraction]));
        AddLine(Lines, Ntabs, new TNumeric(MakeEquality(D.GetNumeric(), TNumeric(" "))));
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhSimplifyingCoefs]));
        AddLine(Lines, Ntabs, new TNumeric(MakeEquality(DSimplified.GetNumeric(), TNumeric(" "))));
        AddLine(Lines, Ntabs, new TText((*Phrases)[PhTakingMajorPart]));
        AddLine(Lines, Ntabs, new TNumeric(MainAndO));
    }
    return true;
}


void TRationalFunctionDerivative::SaveToFile(ofstream &f)
{
__int16 MaxPowerNominator = this->MaxPowerNominator;
__int16 MaxPowerDenominator = this->MaxPowerDenominator;
    f.write((char*)&MaxPowerNominator, sizeof(MaxPowerNominator));
    f.write((char*)&MaxPowerDenominator, sizeof(MaxPowerDenominator));
    UnknownVar.WriteToFile(f);
    TProblem::SaveToFile(f);
}

void TRationalFunctionDerivative::LoadFromFile(ifstream &f)
{
__int16 MaxPowerNominator;
__int16 MaxPowerDenominator;
    f.read((char*)&MaxPowerNominator, sizeof(MaxPowerNominator));
    f.read((char*)&MaxPowerDenominator, sizeof(MaxPowerDenominator));
    this->MaxPowerNominator = MaxPowerNominator;
    this->MaxPowerDenominator = MaxPowerDenominator;
    UnknownVar.LoadFromFile(f);
    TProblem::LoadFromFile(f);
}
