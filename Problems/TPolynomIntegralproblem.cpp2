#include "TPolynomIntegralproblem.h"

#include <iostream>
#include <sstream>

#include "Base/TNumericMask.h"
#include "tsystemofequations.h"

// #define __DEBUG__

TPolynomIntegralProblem::TPolynomIntegralProblem() : TPolynomConditions(8, true, OperatorIntegral) {
    GetRightPartP() = TNumeric("x");  // integral over dx
    BuildPhrases();
}

void TPolynomIntegralProblem::BuildPhrases() {
    if (MyTranslator.CheckDictionary(GetClassName())) return;
    MyTranslator.AddDictionary(GetClassName());
    MyTranslator.AddEng("After simplifying %N");
    MyTranslator.AddRus("После упрощения %N");
    MyTranslator.AddEng("Find indefinite integral of polynom");
    MyTranslator.AddRus("Найти неопределённый интеграл от многочлена");
    MyTranslator.AddEng("polynom");
    MyTranslator.AddRus("многочлен");
}

vector<string> TPolynomIntegralProblem::GetKeyWords() {
    if (MyTranslator.CheckDictionary(GetClassName() + "Keywords") == false) {
        MyTranslator.AddDictionary(GetClassName() + "Keywords");
        MyTranslator.AddEng("integral");
        MyTranslator.AddRus("интеграл");
        MyTranslator.AddEng("polynom");
        MyTranslator.AddRus("многочлен");
    }
    vector<string> Res;
    Res.push_back(MyTranslator.tr("integral"));
    Res.push_back(MyTranslator.tr("polynom"));
    return Res;
}

TPolynomIntegralProblem::TPolynomIntegralProblem(const TPolynomIntegralProblem& D) : TPolynomConditions(D) {
    this->Assign(D);
    BuildPhrases();
}

TPolynomIntegralProblem::~TPolynomIntegralProblem() {}

void TPolynomIntegralProblem::Assign(const TPolynomIntegralProblem& S) {
    Conditions = std::make_shared<TNumeric>(*S.Conditions);
}

string TPolynomIntegralProblem::GetTask() {
    return MyTranslator.tr("Find indefinite integral of polynom");
}

string TPolynomIntegralProblem::GetShortTask() {
    return MyTranslator.tr("polynom");
}

bool TPolynomIntegralProblem::GetSolution(std::shared_ptr<THTMLWriter> Writer) {
    vector<TNumeric> NewCoefs;
    NewCoefs.assign(MaxPower + 2, TNumeric("0"));
    // интегрируем
    for (size_t power = 0; power <= MaxPower; power++) {
        TNumeric Coef = GetCoef(power);
        Coef = Coef / (power + 1);
        NewCoefs[power + 1] = Coef;
    };
    // заполняем ответ
    NewCoefs[0] = TNumeric("C");
    TPolynom P(NewCoefs);
    if (Writer) Writer->AddFormula(P.asNumeric(TNumeric("x")));
    for (size_t power = 0; power <= P.MajorPower(); power++)
        P.Coef[power] = P.Coef[power].Simplify();
    if (Writer) Writer->AddParagraph("After simplifying %N", P.asNumeric(TNumeric("x")));
    Result = P;
    Result.Coef[0] = TNumeric("0");  // константу убиваем, она подразумевается в Result (чтобы не плодить констант)
    return true;
}
//*******************************************************************
void TRationalIntegralProblem::Assign(const TRationalIntegralProblem& S) {
    TRationalFunctionConditions::operator=(*(TRationalFunctionConditions*)&S);
}

TRationalIntegralProblem::TRationalIntegralProblem(size_t MaxPowerNominator, size_t MaxPowerDenominator) :
    TRationalFunctionConditions(OperatorIntegral, true, MaxPowerNominator, MaxPowerDenominator) {
    SetRightPart(TNumeric("x"));
    if (MaxPowerNominator == 4 && MaxPowerDenominator == 5) {
        vector<TNumeric> N;
        N.push_back(TNumeric("1"));
        N.push_back(TNumeric("0"));
        N.push_back(TNumeric("0"));
        N.push_back(TNumeric("0"));
        N.push_back(TNumeric("0"));
        this->SetNominator(TPolynom(N));

        vector<TNumeric> D;
        D.push_back(TNumeric("16"));
        D.push_back(TNumeric("24"));
        D.push_back(TNumeric("25"));
        D.push_back(TNumeric("12"));
        D.push_back(TNumeric("4"));
        D.push_back(TNumeric("0"));
        this->SetDenominator(TPolynom(D));
    };
    if (MaxPowerNominator == 6 && MaxPowerDenominator == 6) {
        vector<TNumeric> N;
        N.push_back(TNumeric("0"));
        N.push_back(TNumeric("-8"));
        N.push_back(TNumeric("4"));
        N.push_back(TNumeric("0"));
        N.push_back(TNumeric("0"));
        N.push_back(TNumeric("0"));
        N.push_back(TNumeric("0"));
        this->SetNominator(TPolynom(N));

        vector<TNumeric> D;
        D.push_back(TNumeric("1"));
        D.push_back(TNumeric("-2"));
        D.push_back(TNumeric("3"));
        D.push_back(TNumeric("-4"));
        D.push_back(TNumeric("3"));
        D.push_back(TNumeric("-2"));
        D.push_back(TNumeric("1"));
        this->SetDenominator(TPolynom(D));
    };
    BuildPhrases();
}

TRationalIntegralProblem::TRationalIntegralProblem(const TRationalIntegralProblem& S) :
    TRationalFunctionConditions(*(TRationalFunctionConditions*)&S) {}

TRationalIntegralProblem::~TRationalIntegralProblem() {}

void TRationalIntegralProblem::BuildPhrases() {
    if (MyTranslator.CheckDictionary(GetClassName())) return;
    MyTranslator.AddDictionary(GetClassName());
    MyTranslator.AddEng("Find indefinite integral of rational function.");
    MyTranslator.AddRus("Найти неопределённый интеграл от рациональной функции");
    MyTranslator.AddEng("rational function");
    MyTranslator.AddRus("рациональная функция");
    MyTranslator.AddEng("Finding roots of denominator");
    MyTranslator.AddRus("Ищем корни знаменателя");
    MyTranslator.AddEng("After casting to common denominator %N");
    MyTranslator.AddRus("После приведения к общему знаменателю %N");
    MyTranslator.AddEng("Findings coefficients %n from %N");
    MyTranslator.AddRus("Находим коэффициенты %n из %N");
    MyTranslator.AddEng("Solving system of linear equations: %N");
    MyTranslator.AddRus("Решаем систему линейных уравнений: %N");
    MyTranslator.AddEng("The source function can be represented as %N");
    MyTranslator.AddRus("Исходная функция может быть представлена как %N");
    MyTranslator.AddEng("General solution: %N");
    MyTranslator.AddRus("Общее решение: %N");
    MyTranslator.AddEng("%N");
    MyTranslator.AddRus("%N");
    MyTranslator.AddEng("Common nominator is %N");
    MyTranslator.AddRus("Общий делитель равен %N");

    MyTranslator.AddEng("Find indefinite integral of rational function.");
    MyTranslator.AddRus("Найти неопределённый интеграл от рациональной функции.");
    MyTranslator.AddEng("rational function");
    MyTranslator.AddRus("рациональная функция");
}

vector<string> TRationalIntegralProblem::GetKeyWords() {
    if (MyTranslator.CheckDictionary(GetClassName() + "Keywords") == false) {
        MyTranslator.AddDictionary(GetClassName() + "Keywords");
        MyTranslator.AddEng("integral");
        MyTranslator.AddRus("интеграл");
        MyTranslator.AddEng("rational");
        MyTranslator.AddRus("рациональная");
    }
    vector<string> Res;
    Res.push_back(MyTranslator.tr("integral"));
    Res.push_back(MyTranslator.tr("rational"));
    return Res;
}

void TRationalIntegralProblem::operator=(const TRationalIntegralProblem& D) {
    Assign(D);
};

string TRationalIntegralProblem::GetTask() {
    return MyTranslator.tr("Find indefinite integral of rational function.");
}

string TRationalIntegralProblem::GetShortTask() {
    return MyTranslator.tr("rational function");
}

bool TRationalIntegralProblem::GetSolution(std::shared_ptr<THTMLWriter> Writer) {
    //*************************** ВЫДЕЛЯЕМ ГЛАВНУЮ ЧАСТЬ
    TPolynom MainPart;
    TPolynom Nominator;
    TPolynom Denominator = this->GetDenominatorP();
    MainPart = this->GetNominatorP().Div(Denominator, &Nominator);
    if (Writer)
        Writer->AddFormula(MakeEquality(
            MakeFrac(GetNominatorP().asNumeric(UnknownVar), GetDenominatorP().asNumeric(UnknownVar)),
            MainPart.asNumeric(UnknownVar) + MakeFrac(Nominator.asNumeric(UnknownVar), Denominator.asNumeric(UnknownVar))));
    //*********************РАЗЛАГАЕМ ЗНАМЕНАТЕЛЬ НА ЭЛЕМЕНТАРНЫЕ ДРОБИ И СОСТАВЛЯЕМ СУММУ ПРАВИЛЬНЫХ ДРОБЕЙ С НЕИЗВЕСТНЫМИ
    // КОЭФФИЦИЕНТАМИ
    TPolynomialEquality Q;
    Q.SetLeftPartP(Denominator);
    if (Writer) Writer->AddParagraph("Finding roots of denominator");
    if (Q.GetSolution(Writer) == false) return false;
    if (Q.AllRootsFound == false) return false;

    size_t VarCount = 0;
    vector<TRationalFunction> ElementarFractions;  // элементарные дроби
    vector<TNumeric> ElementarFractionsNum;        // элементарные дроби
    vector<size_t> RootNum;  // какой по номеру корень стоит в знаменателе элементарной дроби (Q.SquareMods[i] имеет номер
                             // Q.Roots.size() + i)
    vector<size_t> Multiplicity;  // в какой степени стоит корень

    for (size_t i = 0; i < Q.Roots.size(); i++)
        for (size_t j = 1; j <= Q.RootsMultiplicity[i]; j++) {
            ostringstream str;
            str << "a_" << ++VarCount;
            vector<TNumeric> Nominator;
            Nominator.assign(1, TNumeric(str.str()));

            TPolynom DenominatorPowerOne(TNumeric("1"), TNumeric("-1") * Q.Roots[i]);
            TPolynom Denominator;
            if (j > 1)
                Denominator = DenominatorPowerOne ^ j;
            else
                Denominator = DenominatorPowerOne;
            ElementarFractions.push_back(TRationalFunction(Nominator, Denominator));

            TNumeric DenominatorPowerOneNumeric;
            DenominatorPowerOneNumeric = DenominatorPowerOne.asNumeric(UnknownVar);
            TNumeric DenominatorNum = DenominatorPowerOneNumeric ^ j;
            ElementarFractionsNum.push_back(TPolynom(Nominator).asNumeric(UnknownVar) / DenominatorNum);

            RootNum.push_back(i);
            Multiplicity.push_back(j);
        }

    for (size_t i = 0; i < Q.SquareMods.size(); i++)
        for (size_t j = 1; j <= Q.SquareModsMultiplicity[i]; j++) {
            vector<TNumeric> Nominator;
            Nominator.assign(2, TNumeric("0"));
            ostringstream str1;
            str1 << "a_" << ++VarCount;
            Nominator[0] = TNumeric(str1.str());

            ostringstream str2;
            str2 << "a_" << ++VarCount;
            Nominator[1] = TNumeric(str2.str());

            TPolynom DenominatorPowerOne(Q.SquareMods[i]);
            TPolynom Denominator = DenominatorPowerOne ^ j;
            ElementarFractions.push_back(TRationalFunction(Nominator, Denominator));

            TNumeric DenominatorPowerOneNum = Q.SquareMods[i].asNumeric(UnknownVar);
            TNumeric DenominatorNum = DenominatorPowerOneNum ^ j;
            ElementarFractionsNum.push_back(TPolynom(Nominator).asNumeric(UnknownVar) / DenominatorNum);

            RootNum.push_back(i + Q.Roots.size());
            Multiplicity.push_back(j);
        }

    TNumeric BigSum;
    BigSum.operation = OperatorSum;
    for (size_t i = 0; i < ElementarFractions.size(); i++)
        BigSum = BigSum + ElementarFractions[i].asNumeric();
    if (Writer)
        Writer->AddParagraph("Findings coefficients %n from %N", TNumeric("a_i"),
                             MakeEquality(Nominator.asNumeric(UnknownVar) / Denominator.asNumeric(UnknownVar), BigSum));

    // Приводим подобные члены
    TPolynom BigNominator;
    TNumeric BigNominatorNum;
    BigNominatorNum.operation = OperatorSum;
    for (size_t i = 0; i < ElementarFractions.size(); i++) {
        TPolynom Multiplicator = TNumeric("1");
        TNumeric MultiplicatorNum;
        MultiplicatorNum.operation = OperatorProd;
        for (size_t j = 0; j < Q.Roots.size(); j++) {
            size_t power = Q.RootsMultiplicity[j];
            if (j == RootNum[i]) power -= Multiplicity[i];

            TPolynom DenominatorPowerOne(TNumeric("1"), TNumeric("-1") * Q.Roots[j]);
            TPolynom Denominator = DenominatorPowerOne ^ power;
            TNumeric DenominatorNum = (UnknownVar - Q.Roots[j]);
            if (power > 1) DenominatorNum = DenominatorNum ^ TNumeric(power);
            if (power > 0) {
                MultiplicatorNum.OperandsPushback(DenominatorNum);
                Multiplicator = Multiplicator * Denominator;
            };
        }
        for (size_t j = 0; j < Q.SquareMods.size(); j++) {
            size_t power = Q.SquareModsMultiplicity[j];
            if (j + Q.Roots.size() == RootNum[i]) power -= Multiplicity[i];

            TPolynom DenominatorPowerOne(Q.SquareMods[j]);
            TPolynom Denominator = DenominatorPowerOne ^ power;
            TNumeric DenominatorNum = Q.SquareMods[j].asNumeric(UnknownVar);
            if (power > 1) DenominatorNum = DenominatorNum ^ TNumeric(power);
            if (power > 0) {
                MultiplicatorNum.OperandsPushback(DenominatorNum);
                Multiplicator = Multiplicator * Denominator;
            };
        }
        BigNominator = BigNominator + Multiplicator * ElementarFractions[i].Nominator();
        TNumeric NewTerm;
        NewTerm.operation = OperatorFrac;
        NewTerm.OperandsPushback(*ElementarFractionsNum[i].operands[0] * MultiplicatorNum);
        NewTerm.OperandsPushback(*ElementarFractionsNum[i].operands[1] * MultiplicatorNum);
        BigNominatorNum.OperandsPushback(NewTerm);
    }

    /*if(BigNominatorNum.Operands.size() == 1)
        BigNominatorNum = BigNominatorNum.Operands[0];*/

    if (Writer)
        Writer->AddParagraph(
            "After casting to common denominator %N",
            MakeEquality(Nominator.asNumeric(UnknownVar) / Denominator.asNumeric(UnknownVar), BigNominatorNum));

    //******************** СОСТАВЛЯЕМ И РЕШАЕМ СИСТЕМУ УРАВНЕНИЙ ***************************************************
    TSystemOfEquations S;
    S.Variables.clear();
    for (size_t i = 1; i <= VarCount; i++) {
        ostringstream str;
        str << "a_" << i;
        S.Variables.push_back(TNumeric(str.str()));
    };
    S.BeginAddEquations();
    TPolynom Eq = BigNominator - Nominator / Q.LinearMultiplier;  // многочлен по x
    if (Writer) Writer->AddParagraph("Common nominator is %N", MakeEquality(Eq.asNumeric(UnknownVar), TNumeric("0")));
    for (size_t power = 0; power <= Eq.MajorPower(); power++) {
        // уравнение для x^power
        TNumeric LeftPart = Eq.Coef[power];
        TNumeric RightPart("0");
        TNumeric NewEquation = MakeEquality(LeftPart, RightPart);
        S.AddEquation(NewEquation);
    }
    S.EndAddEquations();

    if (Writer) Writer->AddParagraph("Solving system of linear equations: %N", *S.Conditions);

    // решаем систему
    if (Writer) Writer->IncrementNestingLevel();
    if (S.GetSolution(Writer) == false) return false;
    if (Writer) Writer->DecrementNestingLevel();

    //*************************** ВЫПИСЫВАЕМ РАЗЛОЖЕНИЕ НА ЭЛЕМЕНТАРНЫЕ ДРОБИ
    for (size_t i = 0; i < S.Variables.size(); i++)
        for (size_t j = 0; j < ElementarFractions.size(); j++) {
            ElementarFractionsNum[j] = ElementarFractionsNum[j].Substitute(S.Variables[i].strval, S.Answer[i]).Simplify();
        };
    BigNominatorNum.operands.clear();
    BigNominatorNum.OperandsPushback(MainPart.asNumeric(UnknownVar));
    for (size_t j = 0; j < ElementarFractions.size(); j++)
        BigNominatorNum.OperandsPushback(ElementarFractionsNum[j]);
    if (Writer)
        Writer->AddParagraph(
            "The source function can be represented as %N",
            MakeEquality(MakeFrac(GetNominatorP().asNumeric(UnknownVar), GetDenominatorP().asNumeric(UnknownVar)),
                         BigNominatorNum));

    TNumeric Result;
    Result.operation = OperatorSum;
    for (size_t i = 0; i < ElementarFractionsNum.size(); i++) {
        if (ElementarFractionsNum[i] != TNumeric("0")) {
            TElementarFractionIntegralProblem EFI;
            EFI.SetConditions(ElementarFractionsNum[i], UnknownVar.strval);
            if (EFI.GetSolution(Writer) == false) return false;
            Result.OperandsPushback(EFI.Result);
        };
#ifdef __DEBUG__
        if (Result.Operands.size() > 0) {
            cout << Result.CodeBasic() << endl;
            cout << Result.Simplify().CodeBasic() << endl;
        };
#endif
    }
    TPolynomIntegralProblem PIP;
    PIP.SetLeftPartP(MainPart);
    // if(Writer)Writer->IncrementNestingLevel();
    if (PIP.GetSolution(0) == false) return false;  // интегрирование полинома не выводим
    // if(Writer)Writer->DecrementNestingLevel();
    Result.OperandsPushback(PIP.Result.asNumeric(UnknownVar));
    Result.OperandsPushback(TNumeric("C"));
    if (Writer) Writer->AddParagraph("General solution: %N", Result);
    return true;
}

void TRationalIntegralProblem::LoadFromFile(ifstream& f) {
    TProblem::LoadFromFile(f);
}

void TRationalIntegralProblem::SaveToFile(ofstream& f) {
    TProblem::SaveToFile(f);
}

//**********************************************************************************************************************
//**********************************************************************************************************************
void TRationalIntegralProblem2::Assign(const TRationalIntegralProblem2& S) {
    *(this->Conditions) = *S.Conditions;
}

TRationalIntegralProblem2::TRationalIntegralProblem2(size_t MaxPowerNominator, size_t SimpleRoots, size_t SquareEquations) {
    TNumeric R;
    TNumeric Nom, Denom;
    TNumeric UnknownVar("x");
    // Creating Nominator
    for (size_t i = 0; i <= MaxPowerNominator; i++) {
        TNumeric Term;
        if (i == 0) {
            Term = TNumeric("1");
            Term.SetEditableFlags(ConstAllowed);
        } else {
            TNumeric Coef("0");
            Coef.SetEditableFlags(ConstAllowed);
            Term = Coef * (UnknownVar ^ TNumeric(i));
        }
        if (i == 0)
            Nom = Term;
        else
            Nom = Term + Nom;
    };
    // Creating Denominator
    TNumeric Coef0("0");
    Coef0.SetEditableFlags(ConstAllowed);
    TNumeric Coef1("1");
    Coef1.SetEditableFlags(ConstAllowed);
    TNumeric Mult = (Coef0 * UnknownVar + Coef1) ^ Coef1;
    for (size_t i = 0; i < SimpleRoots; i++) {
        if (i == 0)
            Denom = Mult;
        else
            Denom = Mult * Denom;
    }
    TNumeric Mult2 = (Coef0 * (UnknownVar ^ 2) + Coef0 * UnknownVar + Coef1) ^ Coef1;
    for (size_t i = 0; i < SquareEquations; i++) {
        if (i == 0 && SimpleRoots == 0)
            Denom = Mult2;
        else
            Denom = Mult2 * Denom;
    }

    R = MakeFrac(Nom, Denom);

    Conditions = std::make_shared<TNumeric>();
    Conditions->operation = OperatorIntegral;
    Conditions->OperandsPushback(R);
    Conditions->OperandsPushback(TNumeric("x"));

    BuildPhrases();
}

TRationalIntegralProblem2::TRationalIntegralProblem2(const TRationalIntegralProblem2& S) : TProblem(S) {
    Assign(S);
}

TRationalIntegralProblem2::~TRationalIntegralProblem2() {}

void TRationalIntegralProblem2::BuildPhrases() {
    if (MyTranslator.CheckDictionary(GetClassName())) return;
}

vector<string> TRationalIntegralProblem2::GetKeyWords() {
    if (MyTranslator.CheckDictionary(GetClassName() + "Keywords") == false) {
        MyTranslator.AddDictionary(GetClassName() + "Keywords");
        MyTranslator.AddEng("integral");
        MyTranslator.AddRus("интеграл");
        MyTranslator.AddEng("rational");
        MyTranslator.AddRus("рациональная");
    }
    vector<string> Res;
    Res.push_back(MyTranslator.tr("integral"));
    Res.push_back(MyTranslator.tr("rational"));
    return Res;
}

void TRationalIntegralProblem2::operator=(const TRationalIntegralProblem2& D) {
    Assign(D);
};

string TRationalIntegralProblem2::GetTask() {
    return MyTranslator.tr("Find indefinite integral of rational function.");
}

string TRationalIntegralProblem2::GetShortTask() {
    return MyTranslator.tr("rational function");
}

bool TRationalIntegralProblem2::GetSolution(std::shared_ptr<THTMLWriter> Writer) {
    TNumeric Result;
    Result = *Conditions;
    if (Writer) Writer->AddParagraph("General solution: %N", Result);
    return true;
}

void TRationalIntegralProblem2::LoadFromFile(ifstream& f) {
    TProblem::LoadFromFile(f);
}

void TRationalIntegralProblem2::SaveToFile(ofstream& f) {
    TProblem::SaveToFile(f);
}

//**********************************************************************************************************************
//**********************************************************************************************************************
void TIntegralProblem::Assign(const TIntegralProblem& S) {
    Conditions = std::make_shared<TNumeric>(*S.Conditions);
};
TIntegralProblem::TIntegralProblem() {
    Conditions = std::make_shared<TNumeric>();
    Conditions->operation = OperatorSin;
    Conditions->OperandsPushback(TNumeric("x"));
    Conditions->SetEditableFlags(ConstAllowed | FunctionsAllowed);
    BuildPhrases();
};

TIntegralProblem::TIntegralProblem(const TIntegralProblem& S) : TProblem(S) {
    this->Assign(S);
    BuildPhrases();
};

TIntegralProblem::~TIntegralProblem() {}

string TIntegralProblem::GetTask() {
    return MyTranslator.tr("Find integral of the function");
}

string TIntegralProblem::GetShortTask() {
    return MyTranslator.tr("integral");
}

bool TIntegralProblem::GetSolution(std::shared_ptr<THTMLWriter> Writer) {
    TTabularIntegralProblem P;
    P.SetConditions(*Conditions, "x");
    if (P.GetSolution(Writer)) {
        Result = P.Result;
        if (Writer) Writer->AddParagraph("General solution: %N", Result);
        return true;
    }
    return false;
}

void TIntegralProblem::BuildPhrases() {}

vector<string> TIntegralProblem::GetKeyWords() {
    if (MyTranslator.CheckDictionary(GetClassName() + "Keywords") == false) {
        MyTranslator.AddDictionary(GetClassName() + "Keywords");
        MyTranslator.AddEng("integral");
        MyTranslator.AddRus("интеграл");
    }
    vector<string> Res;
    Res.push_back(MyTranslator.tr("integral"));
    return Res;
};

//**********************************************************************************************************************
TElementarFractionIntegralProblem::TElementarFractionIntegralProblem() {
    BuildPhrases();
}

void TElementarFractionIntegralProblem::BuildPhrases() {
    if (MyTranslator.CheckDictionary(GetClassName())) return;
    MyTranslator.AddDictionary(GetClassName());

    MyTranslator.AddEng("After simplifying: %N");
    MyTranslator.AddRus("После упрощения: %N");

    // nothing to add to dictionary
}

bool TElementarFractionIntegralProblem::Integrate1(std::shared_ptr<THTMLWriter> Writer,
                                                   const TNumeric& N,
                                                   string Var,
                                                   TNumeric& Res)  //  a/(b*x + c)
{
    Q_UNUSED(Writer);
    TNumericMask MaskAlg;
    TNumeric Mask;
    Mask.Assign("a/(b*x+c)");
    if (MaskAlg.Match(Mask, N)) {
        TNumeric a = MaskAlg.Coefs["a"];
        TNumeric b = MaskAlg.Coefs["b"];
        TNumeric c = MaskAlg.Coefs["c"];
        if (c.strval == "") MaskAlg.Match(Mask, N);
        Res = (a / b).Simplify() * MakeLn(MakeAbs(b * TNumeric(Var) + c));
        return true;
    }
    return false;
}

bool TElementarFractionIntegralProblem::Integrate2(std::shared_ptr<THTMLWriter> Writer,
                                                   const TNumeric& N,
                                                   string Var,
                                                   TNumeric& Res)  //  a/(b*x + c)^k
{
    Q_UNUSED(Writer);
    TNumericMask MaskAlg;
    TNumeric Mask;
    Mask.Assign("a/((b*x+c)^k)");
    if (MaskAlg.Match(Mask, N)) {
        TNumeric a = MaskAlg.Coefs["a"];
        TNumeric b = MaskAlg.Coefs["b"];
        TNumeric c = MaskAlg.Coefs["c"];
        TNumeric k = MaskAlg.Coefs["k"];
        if (k == TNumeric(1)) {
            Res = (a / b).Simplify() * MakeLn((b * TNumeric(Var) + c).Simplify());
        } else {
            Res = ((a / b) * (TNumeric(1) / (-k + TNumeric("1")))).Simplify() *
                  (((b * TNumeric(Var) + c) ^ (-k + TNumeric("1"))).Simplify());
        };
        return true;
    }
    return false;
}
bool TElementarFractionIntegralProblem::Integrate3(std::shared_ptr<THTMLWriter> Writer,
                                                   const TNumeric& N,
                                                   string Var,
                                                   TNumeric& Res) {
    TNumericMask MaskAlg;
    TNumeric Mask;
#ifdef __DEBUG__
    cout << N.CodeBasic() << endl;
#endif
    Mask.Assign("(d*x+f)/(a*x^2+b*x+c)");
    if (MaskAlg.Match(Mask, N)) {
        TNumeric a = MaskAlg.Coefs["a"];
        if (a.Calculate() < 0 || a == 0) return false;
        TNumeric b = MaskAlg.Coefs["b"];
        TNumeric c = MaskAlg.Coefs["c"];
        TNumeric d = MaskAlg.Coefs["d"];
        TNumeric f = MaskAlg.Coefs["f"];

        if (d == TNumeric("0")) {
            TNumeric Alpha = MakeSqrt(a).Simplify();
            TNumeric Beta = (b / (Alpha * 2)).Simplify();
            TNumeric Gamma2 = (c - (Beta ^ 2)).Simplify();  // Gamma^2
            if (Gamma2.Calculate() < 0) return false;
            TNumeric Gamma = MakeSqrt(Gamma2).Simplify();
            Res = (TNumeric(f) / (Alpha * Gamma)).Simplify() * MakeArctg(((Alpha * TNumeric(Var) + Beta) / Gamma).Simplify());
        } else {
            // Выделяем в числителе производную знаменателя
            TNumeric N1 = (d / (a * 2)).Simplify() *
                          MakeFrac((a * 2).Simplify() * TNumeric(Var) + b, a * (TNumeric(Var) ^ 2) + b * TNumeric(Var) + c);
            TNumeric Res1 = (d / (a * 2)).Simplify() * MakeLn(MakeAbs(a * (TNumeric(Var) ^ 2) + b * TNumeric(Var) + c));
            TNumeric N2 = (f - b * d / (a * 2)).Simplify() / (a * (TNumeric(Var) ^ 2) + b * TNumeric(Var) + c);
            TNumeric Res2;
#ifdef __DEBUG__
            cout << N1.CodeBasic() << endl;
            cout << N2.CodeBasic() << endl;
            cout << N1.Simplify().CodeBasic() << endl;
            N1 = N1.Simplify();
#endif
            if (Writer) Writer->AddParagraph("%N", MakeEquality(N, N1 + N2));
            if (Integrate3(Writer, N2, Var, Res2) == false) return false;
            Res = Res1 + Res2;
#ifdef __DEBUG__
            cout << Res.CodeBasic() << endl;
#endif
        }
        return true;
    }
    return false;
}
bool TElementarFractionIntegralProblem::Integrate4(std::shared_ptr<THTMLWriter> Writer,
                                                   const TNumeric& NConst,
                                                   string Var,
                                                   TNumeric& Res)  //  a/(b*x^2+c*x+d)^k
{
    TNumericMask MaskAlg;
    TNumeric Mask;
    Mask.Assign("(M*x+N)/((a*x^2+b*x+c)^k)");
    if (MaskAlg.Match(Mask, NConst)) {
        TNumeric a = MaskAlg.Coefs["a"];
        if (a.Calculate() < 0 || a == 0) return false;
        TNumeric b = MaskAlg.Coefs["b"];
        TNumeric c = MaskAlg.Coefs["c"];
        TNumeric m = MaskAlg.Coefs["M"];
        TNumeric n = MaskAlg.Coefs["N"];
        TNumeric k = MaskAlg.Coefs["k"];
        if (k.Calculate() < 0) return false;
        if (k.isInteger() == false) return false;
        if (k == TNumeric(1)) return Integrate3(Writer, NConst, Var, Res);
        if (m == TNumeric("0")) {
            TNumeric X(Var);
            TNumeric Beta = (b / (a * 2)).Simplify();
            TNumeric Gamma2 = c - (b ^ 2) / ((a ^ 2) * 4);
            Gamma2 = Gamma2.Simplify();
            TNumeric t = MakeSqrt(a).Simplify() * X + Beta;
            TNumeric Temp = MakeFrac(TNumeric("1"), ((X ^ 2) + Gamma2) ^ k);
            if (IntegrateJn(Writer, Temp, Var, Res) == false) return false;
            Res = (n / a).Simplify() * Res.Substitute("X", t);
            //           Res = (TNumeric(NConst)/(a^k)*Res).Simplify();
            return true;
        } else {
            // Выделяем в числителе производную знаменателя
            TNumeric N1 = (m / (a * 2)).Simplify() *
                          MakeFrac((a * 2).Simplify() * TNumeric(Var) + b, (a * (TNumeric(Var) ^ 2) + b * TNumeric(Var) + c) ^ k);
            TNumeric Res1 = (m / (a * 2)).Simplify() * MakeFrac(TNumeric(1), -k + 1) *
                            MakeFrac(TNumeric("1"), (a * (TNumeric(Var) ^ 2) + b * TNumeric(Var) + c) ^ (k - 1));
            Res1 = Res1.Simplify();
            TNumeric N2 = (n - b * m / (a * 2)).Simplify() / ((a * (TNumeric(Var) ^ 2) + b * TNumeric(Var) + c) ^ k);
            TNumeric Res2;
#ifdef __DEBUG__
            cout << N1.CodeBasic() << endl;
            cout << N1.Simplify().CodeBasic() << endl;
            cout << N2.CodeBasic() << endl;
#endif
            if (Writer) Writer->AddParagraph("%N", MakeEquality(NConst, N1 + N2));
            if (Integrate4(Writer, N2, Var, Res2) == false) return false;
            Res = Res1 + Res2;
            return true;
        }
    }
    return false;
}

bool TElementarFractionIntegralProblem::IntegrateJn(std::shared_ptr<THTMLWriter> Writer,
                                                    const TNumeric& Num,
                                                    string Var,
                                                    TNumeric& Res) {
    // рекуррентная формула для 1/(x^2+a^2)^n
    TNumericMask MaskAlg;
    TNumeric Mask;
    Mask.Assign("1/((x^2+a2)^n)");
#ifdef __DEBUG__
    cout << Num.CodeBasic() << endl;
#endif
    if (MaskAlg.Match(Mask, Num)) {
        TNumeric A2 = MaskAlg.Coefs["a2"];
        if (A2.Calculate() < 0) return false;
        if (A2 == 0) {
            return Integrate1(Writer, Num, Var, Res);
        } else {
            TNumeric N = MaskAlg.Coefs["n"];
            if (N.Calculate() < 0) return false;
            if (N.isInteger() == false) return false;
            if (N == 0) {
                Res = TNumeric(Var);
                return true;
            }
            if (N == 1) {
                return Integrate3(Writer, Num, Var, Res);
            } else {
                TNumeric Nnext = TNumeric(1) / (((TNumeric(Var) ^ TNumeric(2)) + A2) ^ (N - 1));
                // Nnext = Nnext.Simplify(); //нельзя, а то под шаблон не попадёт
                TNumeric X(Var);
                TNumeric Res2;
                if (IntegrateJn(Writer, Nnext, Var, Res2) == false) return false;
                // J_{n+1} = 1/{2na^2} * (a/((x^2+a^2)^n) + (2*n-1)*J_n}
                // J_n = 1/{2(n-1)a^2} * (a/((x^2+a^2)^(n-1)) + (2*(n-1)-1)*J_{n-1}}
                Res = TNumeric(1) / (TNumeric(2) * (N - 1) * A2).Simplify() *
                      ((X / (((X ^ 2) + A2) ^ (N - 1)).Simplify()) + (TNumeric(2) * (N - 1) - 1).Simplify() * Res2);
                if (Writer) Writer->AddFormula(MakeEquality(MakeIntegral(Num, "x"), Res + TNumeric("C")));
                Res = Res.Simplify();
                if (Writer)
                    Writer->AddParagraph("After simplifying: %N", MakeEquality(MakeIntegral(Num, "x"), Res + TNumeric("C")));
                return true;
            };
        };
    };
    return false;
}

TNumeric TElementarFractionIntegralProblem::Integrate(std::shared_ptr<THTMLWriter> Writer, const TNumeric& N, string Var) {
    TNumeric Res;
    if (Writer) Writer->IncrementNestingLevel();
    if (Integrate1(Writer, N, Var, Res) == false)
        if (Integrate2(Writer, N, Var, Res) == false)
            if (Integrate3(Writer, N, Var, Res) == false)
                if (Integrate4(Writer, N, Var, Res) == false) {
                    Res.operation = OperatorIntegral;
                    Res.OperandsPushback(N);
                    Res.OperandsPushback(TNumeric(Var));
                };
    if (Writer) Writer->DecrementNestingLevel();
    return Res;
}

string TElementarFractionIntegralProblem::GetTask() {
    return "TElementarFractionIntegralProblem::GetTask";
}

string TElementarFractionIntegralProblem::GetShortTask() {
    return "TElementarFractionIntegralProblem::GetShortTask";
}

void TElementarFractionIntegralProblem::SetConditions(const TNumeric& N, const string& var) {
    if (Conditions == 0)
        Conditions = std::make_shared<TNumeric>(N);
    else
        *Conditions = N;
    this->Var = var;
}

bool TElementarFractionIntegralProblem::GetSolution(std::shared_ptr<THTMLWriter> Writer) {
    Result = Integrate(Writer, *Conditions, Var);
#ifdef __DEBUG__
    cout << Result.CodeBasic() << endl;
#endif
    return true;
}
//**********************************************************************************************************************
TTabularIntegralProblem::TTabularIntegralProblem() {
    BuildPhrases();
}

void TTabularIntegralProblem::BuildPhrases() {
    if (MyTranslator.CheckDictionary(GetClassName())) return;
    MyTranslator.AddDictionary(GetClassName());

    //    MyTranslator.AddEng("After simplifying: %N");
    //    MyTranslator.AddRus("После упрощения: %N");

    // nothing to add to dictionary
}

bool TTabularIntegralProblem::IntegrateSin(std::shared_ptr<THTMLWriter> Writer,
                                           const TNumeric& N,
                                           string Var,
                                           TNumeric& Res)  //  a/(b*x + c)
{
    Q_UNUSED(Writer);
    TNumericMask MaskAlg;
    TNumeric Mask, BXplusC;
    BXplusC.Assign("b*x+c");
    Mask = MakeProd(TNumeric("a"), MakeSin(BXplusC));
    if (MaskAlg.Match(Mask, N)) {
        TNumeric a = MaskAlg.Coefs["a"];
        TNumeric b = MaskAlg.Coefs["b"];
        TNumeric c = MaskAlg.Coefs["c"];
        TNumeric NewA = TNumeric("-1") * a;
        TNumeric Expr;
        if (b == TNumeric("0"))
            Expr = c;
        else if (c == TNumeric("0"))
            Expr = b * TNumeric("x");
        else
            Expr = b * TNumeric("x") + c;
        if (b != TNumeric("1")) NewA = NewA / b;

        if (b == TNumeric("0")) {  // a*sin(c) ==> a*sin(c)*x
            Res = a * MakeSin(c) * TNumeric(Var);
        } else {
            if (NewA == TNumeric("1"))
                Res = MakeCos(Expr);
            else
                Res = NewA * MakeCos(Expr);
        };
        return true;
    }
    return false;
}

TNumeric TTabularIntegralProblem::Integrate(std::shared_ptr<THTMLWriter> Writer, const TNumeric& N, string Var) {
    TNumeric Res;
    if (Writer) Writer->IncrementNestingLevel();
    if (IntegrateSin(Writer, N, Var, Res) == false) {
        Res.operation = OperatorIntegral;
        Res.OperandsPushback(N);
        Res.OperandsPushback(TNumeric(Var));
    };
    if (Writer) Writer->DecrementNestingLevel();
    return Res;
}

string TTabularIntegralProblem::GetTask() {
    return "TTabularIntegralProblem::GetTask";
}

string TTabularIntegralProblem::GetShortTask() {
    return "TTabularIntegralProblem::GetShortTask";
}

void TTabularIntegralProblem::SetConditions(const TNumeric& N, const string& var) {
    if (Conditions == 0)
        Conditions = std::make_shared<TNumeric>(N);
    else
        *Conditions = N;
    this->Var = var;
}

bool TTabularIntegralProblem::GetSolution(std::shared_ptr<THTMLWriter> Writer) {
    Result = Integrate(Writer, *Conditions, Var);
#ifdef __DEBUG__
    cout << Result.CodeBasic() << endl;
#endif
    return true;
}
